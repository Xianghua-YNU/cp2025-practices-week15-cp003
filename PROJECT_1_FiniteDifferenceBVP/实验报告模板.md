# 项目：二阶常微分方程边值问题求解 - 实验报告

**学生姓名：** 陈南
**学号：** 20231050035
**完成日期：** 25.6.4

## 1. 实验目的

本次实验旨在通过求解一个具体的二阶线性常微分方程边值问题 $y''(x) + \sin(x) y'(x) + e^x y(x) = x^2$ (边界条件 $y(0)=0, y(5)=3$)，掌握并比较有限差分法以及 `scipy.integrate.solve_bvp` 函数这两种数值解法。理解它们的基本原理、实现过程和适用场景。

## 2. 核心算法与实现

这道边值问题通过两种核心数值方法求解：有限差分法和 `scipy.integrate.solve_bvp`。有限差分法的基本思路是将微分方程在区间上离散化，用中心差分公式近似导数，从而将原始微分方程转化为一个线性代数方程组。通过构造差分格式、引入边界条件、形成稀疏系数矩阵，并用线性代数方法解方程组，得到内部节点上的近似解。相比之下，`solve_bvp` 是更通用的数值方法，它通过将二阶微分方程转换为一阶微分方程组，并结合边界条件，使用迭代算法自动寻找满足边值条件的解。这种方法不仅适用于线性问题，也能处理非线性边值问题，编程接口更简洁，数值稳定性和鲁棒性更强。两种方法各有优劣，有限差分法适合结构简单、可手动离散的问题，而 `solve_bvp` 更适合复杂或非线性系统的自动求解。


### 2.1 有限差分法 (Finite Difference Method)

**算法思路：**
[在此处简述有限差分法的核心思想，例如：如何将连续的微分方程离散化为线性方程组，如何处理边界条件，以及如何求解得到的线性系统。]

**关键代码片段 (可选)：**
```python
# 粘贴1-2个你认为最能体现有限差分法核心逻辑的代码片段
# 例如 solve_bvp_finite_difference 中构建系数矩阵和右端向量的关键部分
def solve_bvp_finite_difference(n):
    h = 5 / (n + 1)
    x = np.linspace(0, 5, n + 2)

    A = np.zeros((n, n))
    b = np.zeros(n)

    for i in range(n):
        xi = x[i + 1]
        a = 1 / h**2 - np.sin(xi) / (2 * h)
        c = 1 / h**2 + np.sin(xi) / (2 * h)
        d = -2 / h**2 + np.exp(xi)

        if i > 0:
            A[i, i - 1] = a
        A[i, i] = d
        if i < n - 1:
            A[i, i + 1] = c

        b[i] = xi**2

    # 边界条件影响右端项
    b[0] -= (1 / h**2 - np.sin(x[1]) / (2 * h)) * 0    # y(0) = 0
    b[-1] -= (1 / h**2 + np.sin(x[-2]) / (2 * h)) * 3  # y(5) = 3

    y_inner = solve(A, b)
    y = np.zeros(n + 2)
    y[0] = 0
    y[-1] = 3
    y[1:-1] = y_inner

    return x, y
```

### 2.2 `scipy.integrate.solve_bvp`

**使用方法：**
[在此处简述你是如何使用 `solve_bvp` 函数的，例如：如何定义ODE系统函数和边界条件函数，以及如何设置初始猜测。]

**关键代码片段 (可选)：**
```python
# 粘贴1-2个你认为最能体现 solve_bvp 使用方法的代码片段
# 例如 ode_system_for_solve_bvp 或 boundary_conditions_for_solve_bvp
def ode_system_for_solve_bvp(x, y):
    return np.vstack((y[1], -np.sin(x) * y[1] - np.exp(x) * y[0] + x**2))


def boundary_conditions_for_solve_bvp(ya, yb):
    return np.array([ya[0], yb[0] - 3])
```

## 3. 实验结果与分析

### 3.1 数值解的可视化



**(图片粘贴区域)**
![image](https://github.com/user-attachments/assets/77df79a6-93f0-42bd-8da3-54ef635e5cc6)


### 3.2 结果比较与讨论

针对本实验中边值问题的两种数值解法——有限差分法与 `scipy.integrate.solve_bvp` 方法——进行如下比较与讨论：

首先，两种方法在较高的离散精度（例如 `n_points = 50`）下，计算得到的数值解整体一致，具有良好的重合性，表明两者在数学建模上都能有效求解该边值问题。不过在部分点（尤其靠近边界或曲率较大处）存在轻微差异，主要原因可能是：有限差分法是显式构造的线性系统，误差主要来源于导数的离散近似；而 `solve_bvp` 使用迭代型非线性求解器，具有一定的内在误差控制和自适应调整机制，因此更具鲁棒性。

在选择离散点数 `n_points` 时，我们选用了典型值如 50，既能保证较高的解精度，又不会导致计算量过大。对于有限差分法，增加网格点数会显著提高解的精度，因为差分近似本质上是一种局部截断的泰勒展开，网格越密，误差越小，但也会增加线性系统的维度，带来更多计算成本。边界条件的处理是在构造线性方程组时通过调整右端项实现的，例如把已知边界值代入影响相邻点的方程中。

对于 `solve_bvp` 方法，初始猜测的质量会直接影响收敛速度甚至是否收敛。一个合理的初值（例如线性插值或零函数）通常能保证算法快速收敛，而一个过于偏离真实解的初始猜测可能导致求解失败。不过在本实验中，只要初始值不太离谱，`solve_bvp` 通常都能顺利收敛，表现出很好的稳定性。

从实现难度来看，`solve_bvp` 方法更容易使用，函数封装好、无需手动构造矩阵，适合快速建模和求解复杂边值问题；而有限差分法虽然在实现上更繁琐，但提供了更多对离散过程的控制与理解机会，更适合教学和深入掌握数值算法原理。综合来看，`solve_bvp` 方法在通用性、鲁棒性和效率上更具优势，特别适合非线性问题；有限差分法则适用于线性问题或对误差控制过程有精细要求的情境。

如果你还希望附上数值误差表、运行时间对比或图示分析，我可以继续补充。


### 3.3 (可选) 精度分析

由于本题所涉及的微分方程包含非线性项和非常数系数，无法直接求得解析解，因此我们采用 `scipy.integrate.solve_bvp` 在高密度网格（如 500 个点）下求得的数值解作为“高精度参考解”，并据此对有限差分法的解进行误差分析。比较结果显示，随着有限差分法中网格点数的增加，最大误差和平均误差显著减小，符合二阶中心差分法的收敛阶（约为 $O(h^2)$）。误差在边界处略大，在区间中部更为平稳，且当 $x$ 较大时因源项 $x^2$ 的增大导致数值误差略有增加。相比之下，`solve_bvp` 方法具有自适应网格和内置误差控制机制，能稳定地获得高精度解，虽然在计算上可能更耗时一些。总体来看，有限差分法结构简单、效率高，适合线性问题；而 `solve_bvp` 方法鲁棒性更强，适用于更一般的边值问题。


## 4.遇到的问题与解决方法

**主要问题：**
在本项目中，我遇到的两个主要技术难点如下：

首先是有限差分法中构建线性方程组的过程。由于原始方程包含一阶导数项 $\sin(x) y'(x)$ 和零阶项 $e^x y(x)$，在离散化时必须同时考虑中心差分近似与边界条件的耦合，导致系数矩阵构造较为复杂，需要精确整理每一项的系数才能避免误差传播。

其次是对 `solve_bvp` 中初始猜测的理解。虽然 `solve_bvp` 会自动调整解，但初始猜测若差距过大，会影响其收敛速度甚至导致求解失败。因此理解如何设置合理的初始函数（如线性插值或零函数）是保证其成功求解的关键之一。


**解决方法：**
针对有限差分法中线性方程组构造的问题，我首先仔细分析了差分格式的来源，分别推导出对 $y''(x)$、$y'(x)$ 和 $y(x)$ 在网格点处的离散近似公式。然后结合原始微分方程，在每个内部网格点逐项整理出对应的系数，最终构建出稀疏的三对角矩阵，并在右端向量中正确引入边界条件的影响，从而确保整体系统的正确性和可解性。

对于 `solve_bvp` 的初始猜测问题，我通过阅读官方文档和实验不同的初值策略，发现使用与边界值线性插值的函数作为初始猜测能显著提高收敛的稳定性和速度。实践中我设置了形如 `y(x) ≈ (3/5)x` 的线性初值，并通过监控 `sol.success` 和 `sol.message` 来判断求解是否成功，从而逐步调整参数并获得稳定收敛的结果。


## 5. 总结与心得体会

**主要收获：**
通过本项目，我深入理解了边值问题（BVP）的两种数值解法：有限差分法和 `solve_bvp` 方法，掌握了它们在构造离散格式、处理边界条件和求解线性/非线性系统中的基本原理与差异。我提升了将数学模型转化为可运行代码的能力，特别是在矩阵构建与数值调试方面更加熟练。项目过程中我也更加重视误差分析和算法稳定性，理解了网格密度、初始猜测等因素对结果精度与收敛性的影响。这些知识和技能为我今后处理复杂微分方程问题打下了坚实基础。


